SOLID принципы

S: Single Responsibility Principle (Принцип единственной ответственности).  (Каждый класс должен делать ровно то, что от него хотелось; не пихать в один класс кучу всего)
O: Open-Closed Principle (Принцип открытости-закрытости).  (То, что уже реализовали и что уже работает, нельзя менять. Можно лишь добавлять новые вещи, отдельно от уже созданного, например, наследуя от написанного)
L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).  (Если что-то работает с классом наследником, это должно работать и с базовым классом)
I: Interface Segregation Principle (Принцип разделения интерфейса). (Клиенты не должны зависеть от интерфейсов, которые они не используют. Вместо создания общих интерфейсов следует создавать специфические интерфейсы, предназначенные для конкретных клиентов. Например, не надо писать в базовом классе drawcircle, drawsquare, drawrectangle. Иначе придётся во всех наследниках реализовывать эти методы, хотя для круга метод drawsquare не нужен. Лучше сделать один метод draw)
D: Dependency Inversion Principle (Принцип инверсии зависимостей)  (Классы должны зависеть от абстракций, а не от конкретных реализаций. Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Класс Http не должен знать о том, что именно используется для организации сетевого соединения. Поэтому мы создадим интерфейс Connection. Интерфейс Connection содержит описание метода request и мы передаём классу Http аргумент типа Connection. А дальше мы наследуем 2 класса Json, Xml от Connection, которые уже реализуют конкретный вид подключения)